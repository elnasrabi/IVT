/** @flow */
import expect from 'expect.js'
import React from 'react'
import TestUtils from 'react-addons-test-utils'
import { findDOMNode } from 'react-dom'
import FakeTimers from '@vendor/fake-timers/FakeTimers'
import VirtualScroll from './index'

describe('VirtualScroll', () => {
  let timers
  before(() => timers = new FakeTimers(global))
  after(() => timers.useRealTimers())

  const list = []
  for (var i = 0; i < 100; i++) {
    list.push({
      id: i,
      name: `Row ${i}`
    })
  }

  function renderList ({
    height = 100,
    rowHeight = 10,
    scrollToIndex = undefined,
    rowsCount = list.length
  } = {}) {
    const virtualScroll = TestUtils.renderIntoDocument(
      <VirtualScroll
        height={height}
        rowHeight={rowHeight}
        scrollToIndex={scrollToIndex}
      >
        {list
          .slice(0, rowsCount)
          .map(row => (
            <div
              key={row.id}
              className='listItem'
            >
              {row.name}
            </div>
          ))
        }
      </VirtualScroll>
    )

    // Allow initial setImmediate() to set :scrollTop
    timers.runAllTimers()

    return virtualScroll
  }

  describe('number of rendered children', () => {
    it('should render enough children to fill the view +1 for partial visibility at top and bottom', () => {
      const list = renderList()
      const listDOMNode = findDOMNode(list)

      expect(listDOMNode.querySelectorAll('.listItem').length).to.equal(11)
    })

    it('should not render more children than available if the list is not filled', () => {
      const list = renderList({ rowsCount: 5 })
      const listDOMNode = findDOMNode(list)

      expect(listDOMNode.querySelectorAll('.listItem').length).to.equal(5)
    })
  })

  /** Allows for testing initial rendering of component and scrolling via props */
  describe('scrollToIndex', () => {
    it('should scroll to the top', () => {
      const list = renderList({ scrollToIndex: 0 })
      expect(list.state.scrollTop).to.equal(0)
    })

    it('should scroll down to the middle', () => {
      const list = renderList({ scrollToIndex: 49 })
      // 100 items * 10 item height = 1,000 total item height
      // 10 items can be visible at a time and :scrollTop is initially 0,
      // So the minimum amount of scrolling leaves the 50th item at the bottom (just scrolled into view).
      expect(list.state.scrollTop).to.equal(400)
    })

    it('should scroll to the bottom', () => {
      const list = renderList({ scrollToIndex: 99 })
      // 100 height - 10 header = 90 available scroll space.
      // 100 items * 10 item height = 1,000 total item height
      // Target height for the last item then is 1000 - 90
      expect(list.state.scrollTop).to.equal(900)
    })
  })

  /** Allows more fine-grained control of scrolling from position A to B */
  describe('_calculateScrollTopForIndex', () => {
    function calculateScrollTopForIndex (scrollToIndex, scrollTop = 0) {
      return VirtualScroll._calculateScrollTopForIndex({
        height: 100,
        rowHeight: 10,
        rowsCount: list.length,
        scrollToIndex,
        scrollTop
      })
    }

    it('should scroll to the top', () => {
      expect(calculateScrollTopForIndex(0)).to.equal(0)
    })

    it('should scroll down to the middle', () => {
      expect(calculateScrollTopForIndex(49)).to.equal(400)
    })

    it('should scroll up to the middle', () => {
      expect(calculateScrollTopForIndex(49, 800)).to.equal(490)
    })

    it('should not scroll if an item is already visible', () => {
      expect(calculateScrollTopForIndex(49, 470)).to.equal(470)
    })

    it('should scroll to the bottom', () => {
      expect(calculateScrollTopForIndex(99)).to.equal(900)
    })

    it('should not scroll past the top', () => {
      expect(calculateScrollTopForIndex(-5)).to.equal(0)
    })

    it('should not scroll past the bottom', () => {
      expect(calculateScrollTopForIndex(105)).to.equal(900)
    })
  })

  describe('_getMaxVisibleRows', () => {
    function getMaxVisibleRows (rowsCount) {
      return VirtualScroll._getMaxVisibleRows({
        height: 100,
        rowHeight: 20,
        rowsCount
      })
    }

    it('should handle no rows', () => {
      expect(getMaxVisibleRows(0)).to.equal(0)
    })

    it('should handle when there are fewer rows than available height', () => {
      expect(getMaxVisibleRows(2)).to.equal(2)
    })

    it('should handle when the rows exactly fit', () => {
      expect(getMaxVisibleRows(5)).to.equal(5)
    })

    it('should handle when there are more rows than the available height', () => {
      expect(getMaxVisibleRows(100)).to.equal(6) // Exact fit +1 extra for overlap
    })
  })

  describe('_getStartAndStopIndexForScrollTop', () => {
    function getStartAndStopIndexForScrollTop (scrollTop) {
      return VirtualScroll._getStartAndStopIndexForScrollTop({
        height: 100,
        rowHeight: 20,
        rowsCount: 100,
        scrollTop
      })
    }

    it('should handle unscrolled', () => {
      const { rowIndexStart, rowIndexStop } = getStartAndStopIndexForScrollTop(0)
      expect(rowIndexStart).to.equal(0)
      expect(rowIndexStop).to.equal(5)
    })

    it('should handle scrolled to the middle', () => {
      const { rowIndexStart, rowIndexStop } = getStartAndStopIndexForScrollTop(1000)
      expect(rowIndexStart).to.equal(50)
      expect(rowIndexStop).to.equal(55)
    })

    it('should handle scrolled to the end', () => {
      const { rowIndexStart, rowIndexStop } = getStartAndStopIndexForScrollTop(1920)
      expect(rowIndexStart).to.equal(95)
      expect(rowIndexStop).to.equal(99)
    })

    it('should handle scrolled past the end', () => {
      const { rowIndexStart, rowIndexStop } = getStartAndStopIndexForScrollTop(3000)
      expect(rowIndexStart).to.equal(95)
      expect(rowIndexStop).to.equal(99)
    })

    it('should handle scrolled past the beginning', () => {
      const { rowIndexStart, rowIndexStop } = getStartAndStopIndexForScrollTop(-200)
      expect(rowIndexStart).to.equal(0)
      expect(rowIndexStop).to.equal(5)
    })
  })
})
