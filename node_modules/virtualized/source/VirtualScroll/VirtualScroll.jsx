/** @flow */
import React, { Component, PropTypes } from 'react'
import cn from 'classnames'
import './VirtualScroll.less'

const IS_SCROLLING_TIMEOUT = 150

/**
 * Virtualized list rendering (similar to 'react-infinite').
 */
export default class VirtualScroll extends Component {
  static propTypes = {
    /** Child rows (must be of uniform height) */
    children: PropTypes.node.isRequired,
    /** Optional CSS class name */
    className: PropTypes.string,
    /** Height constraint for list (determines how many actual rows are rendered) */
    height: PropTypes.number.isRequired,
    /** Fixed row height (determines how many actual rows are rendered) */
    rowHeight: PropTypes.number.isRequired,
    /** Row index to ensure visible (by forcefully scrolling if necessary) */
    scrollToIndex: PropTypes.number
  }

  constructor (props, context) {
    super(props, context)

    this.state = {
      isScrolling: false,
      scrollTop: 0
    }

    this._onScroll = this._onScroll.bind(this)
    this._onWheel = this._onWheel.bind(this)
  }

  /**
   * Scroll the list to ensure the row at the specified index is visible.
   * This method exists so that a user can forcefully scroll to the same row twice.
   * (The :scrollToIndex property would not change in that case, so it would not be picked up by the component.)
   */
  scrollToRow (scrollToIndex) {
    this._updateScrollTopForScrollToIndex(scrollToIndex)
  }

  componentDidMount () {
    const { scrollToIndex } = this.props

    if (scrollToIndex >= 0) {
      // Without setImmediate() the initial scrollingContainer.scrollTop assignment doesn't work
      setImmediate(() => {
        this._updateScrollTopForScrollToIndex()
      })
    }
  }

  componentDidUpdate (prevProps, prevState) {
    const { children, scrollToIndex } = this.props
    const { scrollTop } = this.state

    // Make sure any changes to :scrollTop (from :scrollToIndex) get applied
    if (scrollTop >= 0 && scrollTop !== prevState.scrollTop) {
      this.refs.scrollingContainer.scrollTop = scrollTop
    }

    if (
      scrollToIndex >= 0 &&
      scrollToIndex < React.Children.count(children) &&
      scrollToIndex !== prevProps.scrollToIndex
    ) {
      this._updateScrollTopForScrollToIndex()
    }

    // If the number of children has been reduced, make sure the scroll position is still valid
    const rowsCount = React.Children.count(children)
    const previousRowsCount = React.Children.count(prevProps.children)
    if (rowsCount < previousRowsCount) {
      const { height, rowHeight } = this.props
      const calculatedScrollTop = VirtualScroll._calculateScrollTopForIndex({
        height,
        rowHeight,
        rowsCount,
        scrollTop,
        scrollToIndex: rowsCount - 1
      })

      if (calculatedScrollTop < scrollTop) {
        this._updateScrollTopForScrollToIndex(rowsCount - 1)
      }
    }
  }

  render () {
    const {
      children,
      className,
      height,
      rowHeight
    } = this.props
    const {
      isScrolling,
      scrollTop
    } = this.state

    const totalRowsHeight = rowHeight * React.Children.count(children)

    // Shift the visible rows down so that they remain visible while scrolling.
    // This mimicks scrolling behavior within a non-virtualized list.
    const paddingTop = scrollTop - (scrollTop % rowHeight)

    let childrenToDisplay = []

    // Render only enough rows to cover the visible (vertical) area of the table.
    if (height > 0) {
      const {
        rowIndexStart,
        rowIndexStop
      } = VirtualScroll._getStartAndStopIndexForScrollTop({
        height,
        rowHeight,
        rowsCount: React.Children.count(children),
        scrollTop
      })

      childrenToDisplay = React.Children.toArray(children).slice(rowIndexStart, rowIndexStop + 1)
    }

    return (
      <div
        ref='scrollingContainer'
        className={cn('VirtualScroll', className)}
        onScroll={this._onScroll}
        onWheel={this._onWheel}
        style={{
          height: height
        }}
      >
        <div
          style={{
            height: totalRowsHeight,
            maxHeight: totalRowsHeight,
            paddingTop: paddingTop,
            overflow: 'hidden',
            pointerEvents: isScrolling ? 'none' : 'auto'
          }}
        >
          {childrenToDisplay}
        </div>
      </div>
    )
  }

  /**
   * Scroll the table to ensure the specified index is visible.
   *
   * @private
   * Why was this functionality implemented as a method instead of a property?
   * Short answer: A user of this component may want to scroll to the same row twice.
   * In this case the scroll-to-row property would not change and so it would not be picked up by the component.
   */
  static _calculateScrollTopForIndex ({ rowsCount, height, rowHeight, scrollTop, scrollToIndex }) {
    scrollToIndex = Math.max(0, Math.min(rowsCount - 1, scrollToIndex))

    const maxScrollTop = scrollToIndex * rowHeight
    const minScrollTop = maxScrollTop - height + rowHeight
    const newScrollTop = Math.max(minScrollTop, Math.min(maxScrollTop, scrollTop))

    return newScrollTop
  }

  /**
   * Calculates the maximum number of visible rows based on the row-height and the number of rows in the table.
   */
  static _getMaxVisibleRows ({ height, rowHeight, rowsCount }) {
    const minNumRowsToFillSpace = Math.ceil(height / rowHeight)

    // Add one to account for partially-clipped rows on the top and bottom
    const maxNumRowsToFillSpace = minNumRowsToFillSpace + 1

    return Math.min(rowsCount, maxNumRowsToFillSpace)
  }

  /**
   * Calculates the start and end index for visible rows based on a scroll offset.
   * Handles edge-cases to ensure that the table never scrolls past the available rows.
   */
  static _getStartAndStopIndexForScrollTop ({ height, rowHeight, rowsCount, scrollTop }) {
    const maxVisibleRows = VirtualScroll._getMaxVisibleRows({ height, rowHeight, rowsCount })
    const totalRowsHeight = rowHeight * rowsCount
    const safeScrollTop = Math.max(0, Math.min(totalRowsHeight - height, scrollTop))

    let scrollPercentage = safeScrollTop / totalRowsHeight
    let rowIndexStart = Math.floor(scrollPercentage * rowsCount)
    let rowIndexStop = Math.min(rowsCount, rowIndexStart + maxVisibleRows) - 1

    return {
      rowIndexStart,
      rowIndexStop
    }
  }

  /**
   * Updates the state during the next animation frame.
   * Use this method to avoid multiple renders in a small span of time.
   * This helps performance for bursty events (like onWheel).
   */
  _setNextState (state) {
    if (this._setNextStateAnimationFrameId) {
      cancelAnimationFrame(this._setNextStateAnimationFrameId)
    }

    this._setNextStateAnimationFrameId = requestAnimationFrame(() => {
      this._setNextStateAnimationFrameId = null
      this.setState(state)
    })
  }

  /**
   * Sets an :isScrolling flag for a small window of time.
   * This flag is used to disable pointer events on the scrollable portion of the table (the rows).
   * This prevents jerky/stuttery mouse-wheel scrolling.
   */
  _temporarilyDisablePointerEvents () {
    if (this._disablePointerEventsTimeoutId) {
      clearTimeout(this._disablePointerEventsTimeoutId)
    }

    this._disablePointerEventsTimeoutId = setTimeout(() => {
      this._disablePointerEventsTimeoutId = null
      this.setState({
        isScrolling: false
      })
    }, IS_SCROLLING_TIMEOUT)
  }

  /**
   * Calculates and adjusts scrollTop if necessary to ensure that the row at the specified index is visible.
   */
  _updateScrollTopForScrollToIndex (scrollToIndexOverride) {
    const scrollToIndex = scrollToIndexOverride !== undefined
      ? scrollToIndexOverride
      : this.props.scrollToIndex

    const { children, height, rowHeight } = this.props
    const { scrollTop } = this.state

    if (scrollToIndex >= 0) {
      const calculatedScrollTop = VirtualScroll._calculateScrollTopForIndex({
        height,
        rowHeight,
        rowsCount: React.Children.count(children),
        scrollTop,
        scrollToIndex
      })

      if (scrollTop !== calculatedScrollTop) {
        this.setState({ scrollTop: calculatedScrollTop })
      }
    }
  }

  _onScroll (event) {
    // In certain edge-cases React dispatches an onScroll event with an invalid target.scrollTop.
    // This invalid event can be detected by comparing event.target to this component's scrollable DOM element.
    // See issue #404 for more information.
    if (event.target !== this.refs.scrollingContainer) {
      return
    }

    const scrollTop = event.target.scrollTop

    // Certain devices (like Apple touchpad) rapid-fire duplicate events.
    // Don't force a re-render if this is the case.
    if (this.state.scrollTop === scrollTop) {
      return
    }

    // Prevent pointer events from interrupting a smooth scroll
    this._temporarilyDisablePointerEvents()

    // The mouse may move faster then the animation frame does.
    // Use requestAnimationFrame to avoid over-updating.
    this._setNextState({
      isScrolling: true,
      scrollTop
    })
  }

  _onWheel (event) {
    const scrollTop = this.refs.scrollingContainer.scrollTop

    // Certain devices (like Apple touchpad) rapid-fire duplicate events.
    // Don't force a re-render if this is the case.
    if (this.state.scrollTop === scrollTop) {
      return
    }

    // Prevent pointer events from interrupting a smooth scroll
    this._temporarilyDisablePointerEvents()

    // The mouse may move faster then the animation frame does.
    // Use requestAnimationFrame to avoid over-updating.
    this._setNextState({
      isScrolling: true,
      scrollTop
    })
  }
}
