/**
 * Table component with fixed headers and virtualized rows for improved performance with large data sets.
 * This component intentional mimicks the `fixed-data-table` component interface for convenience.
 * @flow
 */
import React, { Component, PropTypes } from 'react'
import cn from 'classnames'
import VirtualScroll from '../VirtualScroll'
import Column from './Column'
import './Table.less'

export const SortDirection = {
  /**
   * Sort items in ascending order.
   * This means arranging from the lowest value to the highest (e.g. a-z, 0-9).
   */
  ASC: 'ASC',

  /**
   * Sort items in descending order.
   * This means arranging from the highest value to the lowest (e.g. z-a, 9-0).
   */
  DESC: 'ASC'
}

/**
 * This table component expects explicit width, height, and padding parameters.
 * This can be useful if you want to display a table with a fixed-sized inside of a page.
 * If you do not want to manage this information, use the AutoSizingTable wrapper component.
 */
export default class Table extends Component {
  static defaultProps = {
    horizontalPadding: 0,
    verticalPadding: 0
  }

  static propTypes = {
    /** One or more Columns describing the data displayed in this row */
    children: (props, propName, componentName) => {
      const children = React.Children.toArray(props.children)
      for (let i = 0; i < children.length; i++) {
        if (children[i].type !== Column) {
          return new Error(`Table only accepts cihldren of type Column`)
        }
      }
    },
    /** Optional CSS class name */
    className: PropTypes.string,
    /** Optional CSS class to apply to all column headers */
    headerClassName: PropTypes.string,
    /** Fixed height of header row */
    headerHeight: PropTypes.number.isRequired,
    /** Fixed/available height for out DOM element */
    height: PropTypes.number.isRequired,
    /** Horizontal padding of outer DOM element */
    horizontalPadding: PropTypes.number,
    /**
     * Callback responsible for returning a data row given an index.
     * (index: int): any
     */
    rowGetter: PropTypes.func.isRequired,
    /** Fixed height of table row */
    rowHeight: PropTypes.number.isRequired,
    /** Number of rows in table. */
    rowsCount: PropTypes.number.isRequired,
    /**
     * Sort function to be called if a sortable header is clicked.
     * (dataKey: string, sortDirection: SortDirection): void
     */
    sort: PropTypes.func,
    /** Table data is currently sorted by this :dataKey (if it is sorted at all) */
    sortBy: PropTypes.string,
    /** Table data is currently sorted in this direction (if it is sorted at all) */
    sortDirection: PropTypes.oneOf(Object.values(SortDirection)),
    /** Fixed/available width for out DOM element */
    width: PropTypes.number.isRequired,
    /** Vertical padding of outer DOM element */
    verticalPadding: PropTypes.number
  }

  /**
   * Scroll the table to ensure the specified index is visible.
   *
   * @private
   * Why was this functionality implemented as a method instead of a property?
   * Short answer: A user of this component may want to scroll to the same row twice.
   * In this case the scroll-to-row property would not change and so it would not be picked up by the component.
   */
  scrollToRow (scrollToIndex) {
    this.refs.VirtualScroll.scrollToRow(scrollToIndex)
  }

  render () {
    const {
      children,
      className,
      headerHeight,
      height,
      rowGetter,
      rowHeight,
      rowsCount,
      verticalPadding,
      width
    } = this.props

    const availableRowsHeight = height - headerHeight - verticalPadding

    const renderedHeaderRow = React.Children.map(
      children,
      (column, columnIndex) => this._createHeader(column, columnIndex)
    )

    const rows = []
    for (var rowIndex = 0; rowIndex < rowsCount; rowIndex++) {
      rows.push(
        <this._createRow
          key={`Row${rowIndex}`}
          columns={children}
          createColumn={this._createColumn.bind(this)}
          rowGetter={rowGetter}
          rowHeight={rowHeight}
          rowIndex={rowIndex}
        />
      )
    }

    return (
      <div
        className={cn('Table', className)}
        style={{
          maxWidth: width
        }}
      >
        <div
          style={{
            height: headerHeight
          }}
          className='Table__headerRow'
        >
          {renderedHeaderRow}
        </div>

        <VirtualScroll
          ref='VirtualScroll'
          width={width}
          height={availableRowsHeight}
          rowHeight={rowHeight}
        >
          {rows}
        </VirtualScroll>
      </div>
    )
  }

  _createColumn (column, columnIndex, rowData, rowIndex) {
    const {
      cellClassName,
      cellDataGetter,
      columnData,
      dataKey,
      cellRenderer
    } = column.props
    const renderedCell = cellRenderer(
      cellDataGetter(dataKey, rowData, columnData),
      dataKey,
      rowData,
      rowIndex,
      columnData
    )

    return (
      <div
        key={`Row${rowIndex}-Col${columnIndex}`}
        className='Table__row__column'
        style={{
          flex: this._getFlexStyleForColumn(column)
        }}
      >
        <div
          className={cn('Table__row__column__truncatedText', cellClassName)}
        >
          {renderedCell}
        </div>
      </div>
    )
  }

  _createHeader (column, columnIndex) {
    const { sort, sortBy, sortDirection } = this.props
    const { dataKey, disableSort, label } = column.props
    const showSortIndicator = sortBy === dataKey
    const sortEnabled = !disableSort && sort

    const classNames = cn('Table__headerRow__column',
      this.props.headerClassName,
      column.props.headerClassName,
      {
        'Table__headerRow__column--sortable': sortEnabled
      }
    )
    const style = {
      flex: this._getFlexStyleForColumn(column)
    }

    // If this is a sortable header, clicking it should update the table data's sorting.
    const newSortDirection = sortBy !== dataKey || sortDirection === SortDirection.DESC
      ? SortDirection.ASC
      : SortDirection.DESC
    const onClick = () => sortEnabled && sort(dataKey, newSortDirection)

    return (
      <div
        key={`Header-Col${columnIndex}`}
        className={classNames}
        style={style}
        onClick={onClick}
      >
        <div className='Table__headerRow__truncatedText'>
          {label}
        </div>
        {showSortIndicator &&
          <SortIndicator sortDirection={sortDirection} />
        }
      </div>
    )
  }

  _createRow ({ columns, createColumn, rowGetter, rowHeight, rowIndex }) {
    const renderedRow = React.Children.map(
      columns,
      (column, columnIndex) => createColumn(
        column,
        columnIndex,
        rowGetter(rowIndex),
        rowIndex
      )
    )

    return (
      <div
        className='Table__row'
        style={{
          height: rowHeight
        }}
      >
        {renderedRow}
      </div>
    )
  }

  /**
   * Determines the flex-shrink, flex-grow, and width values for a cell (header or column).
   */
  _getFlexStyleForColumn (column) {
    const flex = []
    flex.push(column.props.flexGrow)
    flex.push(column.props.flexShrink)
    flex.push(
      column.props.width
        ? `${column.props.width}px`
        : 'auto'
    )

    return flex.join(' ')
  }
}

export class SortIndicator extends Component {
  static propTypes = {
    sortDirection: PropTypes.oneOf(Object.values(SortDirection))
  }

  render () {
    const { sortDirection } = this.props

    return (
      <svg
        className='Table__headerRow__SortIndicator'
        width={18}
        height={18}
        viewBox='0 0 24 24'
        xmlns='http://www.w3.org/2000/svg'
      >
        {sortDirection === SortDirection.ASC
          ? <path d='M7 14l5-5 5 5z'/>
          : <path d='M7 10l5 5 5-5z'/>
        }
        <path d='M0 0h24v24H0z' fill='none'/>
      </svg>
    )
  }
}
